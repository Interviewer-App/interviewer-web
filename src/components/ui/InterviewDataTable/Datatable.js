"use client";
import * as React from "react";
import {
  flexRender,
  getCoreRowModel,
  useReactTable,
  getPaginationRowModel,
  getSortedRowModel,
  getFilteredRowModel,
} from "@tanstack/react-table";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Input } from "@/components/ui/input";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import { useToast } from "@/hooks/use-toast";

export function DataTable({ columns, data }) {
  const [sorting, setSorting] = React.useState([]);
  const [columnFilters, setColumnFilters] = React.useState([]);
  const [columnVisibility, setColumnVisibility] = React.useState({});
  const [rowSelection, setRowSelection] = React.useState({});
  const { toast } = useToast();

  const table = useReactTable({
    data,
    columns,
    onSortingChange: setSorting,
    onColumnFiltersChange: setColumnFilters,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    onColumnVisibilityChange: setColumnVisibility,
    onRowSelectionChange: setRowSelection,
    state: {
      sorting,
      columnFilters,
      columnVisibility,
      rowSelection,
    },
  });

  const exportToPDF = () => {
    try {
      // Initialize jsPDF document
      const doc = new jsPDF({
        orientation: "portrait",
        unit: "mm",
        format: "a4",
      });

      // Add a title
      doc.setFontSize(18);
      doc.setFont("helvetica", "bold");
      doc.text("Data Report", 14, 20);

      // Add metadata
      doc.setFontSize(10);
      doc.setFont("helvetica", "normal");
      const currentDate = new Date().toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
      doc.text(`Generated on: ${currentDate}`, 14, 30);

      // Get visible columns and their headers, excluding specific columns
      const visibleColumns = table
        .getAllColumns()
        .filter((column) => column.getIsVisible())
        .filter(
          (column) => !["select", "startBtn", "actions"].includes(column.id)
        );

      const headers = visibleColumns.map((column) => {
        // Use the column header or fallback to column ID
        const headerContent = column.columnDef.header;
        if (typeof headerContent === "string") return headerContent;
        // If header is a component, use column ID as fallback
        return column.id;
      });

      // Extract data for each row
      const body = table.getRowModel().rows.map((row) => {
        return visibleColumns.map((column) => {
          const cellValue = row.getValue(column.id);

          // Format dates if detected
          if (cellValue instanceof Date) {
            return cellValue.toLocaleString();
          }

          // Handle other special formatting if needed
          if (cellValue !== null && typeof cellValue === "object") {
            return JSON.stringify(cellValue);
          }

          return cellValue?.toString() || "";
        });
      });

      // Calculate column widths dynamically based on content
      const pageWidth = doc.internal.pageSize.getWidth() - 28; // minus margins
      const columnCount = visibleColumns.length;
      const baseWidth = pageWidth / columnCount;

      // Create column styles with dynamic widths
      const columnStyles = {};
      visibleColumns.forEach((column, index) => {
        columnStyles[index] = { cellWidth: baseWidth };
      });

      // Add the table with custom styling
      autoTable(doc, {
        startY: 40, // Start table below the header
        head: [headers],
        body: body,
        columnStyles: columnStyles,
        styles: {
          fontSize: 10,
          cellPadding: 2,
          overflow: "linebreak",
          halign: "left",
        },
        headStyles: {
          fillColor: [41, 128, 185], // Blue header background
          textColor: [255, 255, 255], // White text
          fontStyle: "bold",
        },
        alternateRowStyles: {
          fillColor: [240, 240, 240], // Light gray for alternate rows
        },
        margin: { top: 40, left: 14, right: 14 },
        didDrawPage: (data) => {
          // Add footer with page number
          const pageCount = doc.internal.getNumberOfPages();
          const pageNumber = data.pageNumber;
          doc.setFontSize(8);
          doc.setTextColor(150);
          doc.text(
            `Page ${pageNumber} of ${pageCount}`,
            data.settings.margin.left,
            doc.internal.pageSize.height - 10
          );
          doc.text(
            "Generated by Coullax Interview System",
            doc.internal.pageSize.width - 60,
            doc.internal.pageSize.height - 10
          );
        },
      });

      // Add a summary section
      const finalY = doc.lastAutoTable.finalY || 40;
      doc.setFontSize(12);
      doc.setFont("helvetica", "bold");
      doc.text("Summary", 14, finalY + 10);
      doc.setFontSize(10);
      doc.setFont("helvetica", "normal");
      doc.text(`Total Records: ${body.length}`, 14, finalY + 16);
      doc.text(
        `Selected Records: ${Object.keys(rowSelection).length}`,
        14,
        finalY + 22
      );

      // Save the PDF
      doc.save(
        `InterviewSession_Report_${new Date().toISOString().slice(0, 10)}.pdf`
      );

      toast({
        title: "Exported to PDF",
        description: "The data has been successfully exported to PDF.",
      });
    } catch (error) {
      console.log("Error exporting to PDF:", error);
      toast({
        title: "Export Failed",
        description: "There was an error while exporting to PDF.",
        variant: "destructive",
      });
    }
  };

  return (
    <div className=" w-full">
      <div className="flex items-center justify-between py-4">
        <Input
          placeholder="Filter emails..."
          value={table.getColumn("email")?.getFilterValue() ?? ""}
          onChange={(event) =>
            table.getColumn("email")?.setFilterValue(event.target.value)
          }
          className="max-w-sm"
        />
        <div className="flex items-center space-x-4">
          <Button
            variant="outline"
            className="max-w-[120px]"
            onClick={exportToPDF}
          >
            Export PDF
          </Button>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" className="max-w-[120px] ml-auto">
                Columns
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent
              align="end"
              className="bg-black bg-opacity-100 shadow-lg"
            >
              {table
                .getAllColumns()
                .filter((column) => column.getCanHide())
                .map((column) => {
                  return (
                    <DropdownMenuCheckboxItem
                      key={column.id}
                      className="capitalize"
                      checked={column.getIsVisible()}
                      onCheckedChange={(value) => {
                        setColumnVisibility((prev) => ({
                          ...prev,
                          [column.id]: value,
                        }));
                        column.toggleVisibility(!!value);
                      }}
                    >
                      {column.id}
                    </DropdownMenuCheckboxItem>
                  );
                })}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      <div className="overflow-x-auto">
        <Table className="min-w-full">
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id} className="p-4 text-left">
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow key={row.id}>
                  {row.getVisibleCells().map((cell) => (
                    <TableCell
                      key={cell.id}
                      className="p-4 border-b md:border-none"
                    >
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={columns.length}
                  className="h-24 text-center"
                >
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
